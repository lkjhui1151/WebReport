[
    {
        "port": "8888",
        "host": "https://localhost:8888/dvwa/vulnerabilities/sqli_blind/ [id parameter]\nhttps://localhost:8888/dvwa/vulnerabilities/brute/ [username parameter]\nhttps://localhost:8888/dvwa/vulnerabilities/sqli/ [id parameter]",
        "name": "SQL injection",
        "description": "SQL injection vulnerabilities arise when user-controllable data is incorporated into database SQL queries in an unsafe manner. An attacker can supply crafted input to break out of the data context in which their input appears and interfere with the structure of the surrounding query.\nA wide range of damaging attacks can often be delivered via SQL injection, including reading or modifying critical application data, interfering with application logic, escalating privileges within the database and taking control of the database server. ",
        "solution": "The most effective way to prevent SQL injection attacks is to use parameterized queries (also known as prepared statements) for all database access. This method uses two steps to incorporate potentially tainted data into SQL queries: first, the application specifies the structure of the query, leaving placeholders for each item of user input; second, the application specifies the contents of each placeholder. Because the structure of the query has already been defined in the first step, it is not possible for malformed data in the second step to interfere with the query structure. You should review the documentation for your database and application platform to determine the appropriate APIs which you can use to perform parameterized queries. It is strongly recommended that you parameterize every variable data item that is incorporated into database queries, even if it is not obviously tainted, to prevent oversights occurring and avoid vulnerabilities being introduced by changes elsewhere within the code base of the application.\nYou should be aware that some commonly employed and recommended mitigations for SQL injection vulnerabilities are not always effective: \n\n  One common defense is to double up any single quotation marks appearing within user input before incorporating that input into a SQL query. This defense is designed to prevent malformed data from terminating the string into which it is inserted. However, if the data being incorporated into queries is numeric, then the defense may fail, because numeric data may not be encapsulated within quotes, in which case only a space is required to break out of the data context and interfere with the query. Further, in second-order SQL injection attacks, data that has been safely escaped when initially inserted into the database is subsequently read from the database and then passed back to it again. Quotation marks that have been doubled up initially will return to their original form when the data is reused, allowing the defense to be bypassed.\n  Another often cited defense is to use stored procedures for database access. While stored procedures can provide security benefits, they are not guaranteed to prevent SQL injection attacks. The same kinds of vulnerabilities that arise within standard dynamic SQL queries can arise if any SQL is dynamically constructed within stored procedures. Further, even if the procedure is sound, SQL injection can arise if the procedure is invoked in an unsafe manner using user-controllable data.\n",
        "remark": "https://portswigger.net/web-security/sql-injection\nhttps://support.portswigger.net/customer/portal/articles/1965677-using-burp-to-test-for-injection-flaws\nhttps://portswigger.net/web-security/sql-injection/cheat-sheet",
        "color": "#FF0000",
        "severity": "High",
        "no": 1
    },
    {
        "port": "8888",
        "host": "https://localhost:8888/dvwa/vulnerabilities/exec/ [ip parameter]",
        "name": "OS command injection",
        "description": "Operating system command injection vulnerabilities arise when an application incorporates user-controllable data into a command that is processed by a shell command interpreter. If the user data is not strictly validated, an attacker can use shell metacharacters to modify the command that is executed, and inject arbitrary further commands that will be executed by the server.\nOS command injection vulnerabilities are usually very serious and may lead to compromise of the server hosting the application, or of the application's own data and functionality. It may also be possible to use the server as a platform for attacks against other systems. The exact potential for exploitation depends upon the security context in which the command is executed, and the privileges that this context has regarding sensitive resources on the server.",
        "solution": "If possible, applications should avoid incorporating user-controllable data into operating system commands. In almost every situation, there are safer alternative methods of performing server-level tasks, which cannot be manipulated to perform additional commands than the one intended.\nIf it is considered unavoidable to incorporate user-supplied data into operating system commands, the following two layers of defense should be used to prevent attacks: \n\n  The user data should be strictly validated. Ideally, a whitelist of specific accepted values should be used. Otherwise, only short alphanumeric strings should be accepted. Input containing any other data, including any conceivable shell metacharacter or whitespace, should be rejected.\n  The application should use command APIs that launch a specific process via its name and command-line parameters, rather than passing a command string to a shell interpreter that supports command chaining and redirection. For example, the Java API Runtime.exec and the ASP.NET API Process.Start do not support shell metacharacters. This defense can mitigate the impact of an attack even in the event that an attacker circumvents the input validation defenses.\n",
        "remark": "https://portswigger.net/web-security/os-command-injection",
        "color": "#FF0000",
        "severity": "High",
        "no": 2
    },
    {
        "port": "8888",
        "host": "https://localhost:8888/dvwa/vulnerabilities/csrf/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/sqli/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/view_source.php [security parameter]\nhttps://localhost:8888/dvwa/vulnerabilities/view_source.php [id parameter]\nhttps://localhost:8888/dvwa/vulnerabilities/upload/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/csrf/test_credentials.php [username parameter]\nhttps://localhost:8888/dvwa/vulnerabilities/javascript/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/fi/ [Referer HTTP header]\nhttps://localhost:8888/dvwa/vulnerabilities/sqli_blind/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/fi/ [User-Agent HTTP header]\nhttps://localhost:8888/dvwa/vulnerabilities/xss_s/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/csp/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/csp/ [include parameter]\nhttps://localhost:8888/dvwa/vulnerabilities/xss_r/ [name parameter]\nhttps://localhost:8888/dvwa/vulnerabilities/xss_r/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/captcha/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/brute/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/fi/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/weak_id/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/exec/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/xss_d/ [security cookie]",
        "name": "Cross-site scripting (reflected)",
        "description": "Reflected cross-site scripting vulnerabilities arise when data is copied from a request and echoed into the application's immediate response in an unsafe way. An attacker can use the vulnerability to construct a request that, if issued by another application user, will cause JavaScript code supplied by the attacker to execute within the user's browser in the context of that user's session with the application.\nThe attacker-supplied code can perform a wide variety of actions, such as stealing the victim's session token or login credentials, performing arbitrary actions on the victim's behalf, and logging their keystrokes.\nUsers can be induced to issue the attacker's crafted request in various ways. For example, the attacker can send a victim a link containing a malicious URL in an email or instant message. They can submit the link to popular web sites that allow content authoring, for example in blog comments. And they can create an innocuous looking web site that causes anyone viewing it to make arbitrary cross-domain requests to the vulnerable application (using either the GET or the POST method).\nThe security impact of cross-site scripting vulnerabilities is dependent upon the nature of the vulnerable application, the kinds of data and functionality that it contains, and the other applications that belong to the same domain and organization. If the application is used only to display non-sensitive public content, with no authentication or access control functionality, then a cross-site scripting flaw may be considered low risk. However, if the same application resides on a domain that can access cookies for other more security-critical applications, then the vulnerability could be used to attack those other applications, and so may be considered high risk. Similarly, if the organization that owns the application is a likely target for phishing attacks, then the vulnerability could be leveraged to lend credibility to such attacks, by injecting Trojan functionality into the vulnerable application and exploiting users' trust in the organization in order to capture credentials for other applications that it owns. In many kinds of application, such as those providing online banking functionality, cross-site scripting should always be considered high risk. ",
        "solution": "In most situations where user-controllable data is copied into application responses, cross-site scripting \n  attacks can be prevented using two layers of defenses:\n\n  Input should be validated as strictly as possible on arrival, given the kind of content that \nit is expected to contain. For example, personal names should consist of alphabetical \nand a small range of typographical characters, and be relatively short; a year of birth \nshould consist of exactly four numerals; email addresses should match a well-defined \nregular expression. Input which fails the validation should be rejected, not sanitized.\nUser input should be HTML-encoded at any point where it is copied into \napplication responses. All HTML metacharacters, including &lt; &gt; \" ' and =, should be \nreplaced with the corresponding HTML entities (&amp;lt; &amp;gt; etc).\nIn cases where the application's functionality allows users to author content using \n  a restricted subset of HTML tags and attributes (for example, blog comments which \n  allow limited formatting and linking), it is necessary to parse the supplied HTML to \n  validate that it does not use any dangerous syntax; this is a non-trivial task.",
        "remark": "https://portswigger.net/web-security/cross-site-scripting\nhttps://portswigger.net/web-security/cross-site-scripting/reflected\nhttps://support.portswigger.net/customer/portal/articles/1965737-Methodology_XSS.html",
        "color": "#FF0000",
        "severity": "High",
        "no": 3
    },
    {
        "port": "8888",
        "host": "https://localhost:8888/dvwa/vulnerabilities/fi/ [page parameter]",
        "name": "External service interaction (HTTP)",
        "description": "External service interaction arises when it is possible to induce an application to interact with an arbitrary external service, such as a web or mail server. The ability to trigger arbitrary external service interactions does not constitute a vulnerability in its own right, and in some cases might even be the intended behavior of the application.\nHowever, in many cases, it can indicate a vulnerability with serious consequences.\nThe ability to send requests to other systems can allow the vulnerable server to be used as an attack proxy.\n  By submitting suitable payloads, an attacker can cause the application server to attack other systems that it can interact with. \n  This may include public third-party systems, internal systems within the same organization, or services available on the local loopback adapter of the application server itself. \n  Depending on the network architecture, this may expose highly vulnerable internal services that are not otherwise accessible to external attackers. ",
        "solution": "You should review the purpose and intended use of the relevant application functionality, \n  and determine whether the ability to trigger arbitrary external service interactions is intended behavior. \n  If so, you should be aware of the types of attacks that can be performed via this behavior and take appropriate measures. \n  These measures might include blocking network access from the application server to other internal systems, and hardening the application server itself to remove any services available on the local loopback adapter.\nIf the ability to trigger arbitrary external service interactions is not intended behavior, then you should implement a whitelist of permitted services and hosts, and block any interactions that do not appear on this whitelist.\n\nOut-of-Band Application Security Testing (OAST) is highly effective at uncovering high-risk features, to the point where finding the root cause of an interaction can be quite challenging. To find the source of an external service interaction, try to identify whether it is triggered by specific application functionality, or occurs indiscriminately on all requests. If it occurs on all endpoints, a front-end CDN or application firewall may be responsible, or a back-end analytics system parsing server logs. In some cases, interactions may originate from third-party systems; for example, a HTTP request may trigger a poisoned email which passes through a link-scanner on its way to the recipient.",
        "remark": "https://portswigger.net/blog/introducing-burp-collaborator\nhttps://portswigger.net/burp/application-security-testing/oast\nhttps://portswigger.net/research/cracking-the-lens-targeting-https-hidden-attack-surface",
        "color": "#FF0000",
        "severity": "High",
        "no": 4
    },
    {
        "port": "8888",
        "host": "https://localhost:8888/dvwa/vulnerabilities/fi/ [page parameter]",
        "name": "External service interaction (DNS)",
        "description": "External service interaction arises when it is possible to induce an application to interact with an arbitrary external service, such as a web or mail server. The ability to trigger arbitrary external service interactions does not constitute a vulnerability in its own right, and in some cases might even be the intended behavior of the application.\nHowever, in many cases, it can indicate a vulnerability with serious consequences.\nIn cases where DNS-based interactions can be triggered, it is normally possible to trigger interactions using other service types, and these are reported as separate issues. \n  If a payload that specifies a particular service type (e.g. a URL) triggers only a DNS-based interaction, \n  then this strongly indicates that the application attempted to connect using that other service, \n  but was prevented from doing so by egress filters in place at the network layer. The ability to send requests to other systems can allow the vulnerable server to be used as an attack proxy.\n  By submitting suitable payloads, an attacker can cause the application server to attack other systems that it can interact with. \n  This may include public third-party systems, internal systems within the same organization, or services available on the local loopback adapter of the application server itself. \n  Depending on the network architecture, this may expose highly vulnerable internal services that are not otherwise accessible to external attackers. ",
        "solution": "You should review the purpose and intended use of the relevant application functionality, \n  and determine whether the ability to trigger arbitrary external service interactions is intended behavior. \n  If so, you should be aware of the types of attacks that can be performed via this behavior and take appropriate measures. \n  These measures might include blocking network access from the application server to other internal systems, and hardening the application server itself to remove any services available on the local loopback adapter.\nIf the ability to trigger arbitrary external service interactions is not intended behavior, then you should implement a whitelist of permitted services and hosts, and block any interactions that do not appear on this whitelist.\n\nOut-of-Band Application Security Testing (OAST) is highly effective at uncovering high-risk features, to the point where finding the root cause of an interaction can be quite challenging. To find the source of an external service interaction, try to identify whether it is triggered by specific application functionality, or occurs indiscriminately on all requests. If it occurs on all endpoints, a front-end CDN or application firewall may be responsible, or a back-end analytics system parsing server logs. In some cases, interactions may originate from third-party systems; for example, a HTTP request may trigger a poisoned email which passes through a link-scanner on its way to the recipient.",
        "remark": "https://portswigger.net/blog/introducing-burp-collaborator\nhttps://portswigger.net/burp/application-security-testing/oast\nhttps://portswigger.net/research/cracking-the-lens-targeting-https-hidden-attack-surface",
        "color": "#FF0000",
        "severity": "High",
        "no": 5
    },
    {
        "port": "8888",
        "host": "https://localhost:8888/dvwa/vulnerabilities/xss_d/",
        "name": "Cross-site scripting (DOM-based)",
        "description": "DOM-based vulnerabilities arise when a client-side script reads data from a controllable part of the DOM (for example, the URL) and processes this data in an unsafe way.\nDOM-based cross-site scripting arises when a script  writes controllable data into the HTML document in an unsafe way. An attacker may be able to use the vulnerability to construct a URL that, if visited by another application user, will cause JavaScript code supplied by the attacker to execute within the user's browser in the context of that user's session with the application.\nThe attacker-supplied code can perform a wide variety of actions, such as stealing the victim's session token or login credentials, performing arbitrary actions on the victim's behalf, and logging their keystrokes.\nUsers can be induced to visit the attacker's crafted URL in various ways, similar to the usual attack delivery vectors for reflected cross-site scripting vulnerabilities.\n\nBurp Suite automatically identifies this issue using static code analysis, which may lead to false positives that are not actually exploitable. The relevant code and execution paths should be reviewed to determine whether this vulnerability is indeed present, or whether mitigations are in place that would prevent exploitation.",
        "solution": "The most effective way to avoid DOM-based cross-site scripting vulnerabilities is not to dynamically write data from any untrusted source into the HTML document. If the desired functionality of the application means that this behavior is unavoidable, then defenses must be implemented within the client-side code to prevent malicious data from introducing script code into the document. In many cases, the relevant data can be validated on a whitelist basis, to allow only content that is known to be safe. In other cases, it will be necessary to sanitize or encode the data. This can be a complex task, and depending on the context that the data is to be inserted may need to involve a combination of JavaScript escaping, HTML encoding, and URL encoding, in the appropriate sequence. ",
        "remark": "https://portswigger.net/web-security/cross-site-scripting\nhttps://portswigger.net/web-security/cross-site-scripting/dom-based",
        "color": "#FF0000",
        "severity": "High",
        "no": 6
    },
    {
        "port": "8888",
        "host": "https://localhost:8888/dvwa/vulnerabilities/fi/ [page parameter]",
        "name": "File path traversal",
        "description": "File path traversal vulnerabilities arise when user-controllable data is used within a filesystem operation in an unsafe manner. Typically, a user-supplied filename is appended to a directory prefix in order to read or write the contents of a file. If vulnerable, an attacker can supply path traversal sequences (using dot-dot-slash characters) to break out of the intended directory and read or write files elsewhere on the filesystem.\nThis is typically a very serious vulnerability, enabling an attacker to access sensitive files containing configuration data, passwords, database records, log data, source code, and program scripts and binaries. ",
        "solution": "Ideally, application functionality should be designed in such a way that user-controllable data does not need to be passed to filesystem operations. This can normally be achieved by referencing known files via an index number rather than their name, and using application-generated filenames to save user-supplied file content.\nIf it is considered unavoidable to pass user-controllable data to a filesystem operation, three layers of defense can be employed to prevent path traversal attacks: \nUser-controllable data should be strictly validated before being passed to any filesystem operation. In particular, input containing dot-dot sequences should be blocked.After validating user input, the application can use a suitable filesystem API to verify that the file to be accessed is actually located within the base directory used by the application. In Java, this can be achieved by instantiating a java.io.File object using the user-supplied filename and then calling the getCanonicalPath method on this object. If the string returned by this method does not begin with the name of the start directory, then the user has somehow bypassed the application's input filters, and the request should be rejected. In ASP.NET, the same check can be performed by passing the user-supplied filename to the System.Io.Path.GetFullPath method and checking the returned string in the same way as described for Java.The directory used to store files that are accessed using user-controllable data can be located on a separate logical volume to other sensitive application and operating system files, so that these cannot be reached via path traversal attacks. In Unix-based systems, this can be achieved using a chrooted filesystem; on Windows, this can be achieved by mounting the base directory as a new logical drive and using the associated drive letter to access its contents.",
        "remark": "https://portswigger.net/web-security/file-path-traversal",
        "color": "#FF0000",
        "severity": "High",
        "no": 7
    },
    {
        "port": "8888",
        "host": "https://localhost:8888/dvwa/vulnerabilities/fi/ [page parameter]",
        "name": "Out-of-band resource load (HTTP)",
        "description": "Out-of-band resource load arises when it is possible to induce an application to fetch content from an arbitrary external location, and incorporate that content into the application's own response(s). The ability to trigger arbitrary out-of-band resource load does not constitute a vulnerability in its own right, and in some cases might even be the intended behavior of the application. \nHowever, in many cases, it can indicate a vulnerability with serious consequences.\nThe ability to request and retrieve web content from other systems can allow the application server to be used as a two-way attack proxy. \n  By submitting suitable payloads, an attacker can cause the application server to attack, or retrieve content from, other systems that it can interact with. \n  This may include public third-party systems, internal systems within the same organization, or services available on the local loopback adapter of the application server itself. \n  Depending on the network architecture, this may expose highly vulnerable internal services that are not otherwise accessible to external attackers.\nAdditionally, the application's processing of web content that is retrieved from arbitrary URLs exposes some important and non-conventional attack surface. \n  An attacker can deploy a web server that returns malicious content, and then induce the application to retrieve and process that content. \n  This processing might give rise to the types of input-based vulnerabilities that are normally found when unexpected input is submitted directly in requests to the application. \n  The out-of-band attack surface that the application exposes should be thoroughly tested for these types of vulnerabilities. ",
        "solution": "You should review the purpose and intended use of the relevant application functionality, and determine whether the ability to trigger arbitrary out-of-band resource load is intended behavior. \n  If so, you should be aware of the types of attacks that can be performed via this behavior and take appropriate measures. \n  These measures might include blocking network access from the application server to other internal systems, and hardening the application server itself to remove any services available on the local loopback adapter. \nYou should also ensure that content retrieved from other systems is processed in a safe manner, with the usual precautions that are applicable when processing input from direct incoming web requests.\nIf the ability to trigger arbitrary out-of-band resource load is not intended behavior, then you should implement a whitelist of permitted URLs, and block requests to URLs that do not appear on this whitelist.",
        "remark": "https://portswigger.net/blog/introducing-burp-collaborator\nhttps://portswigger.net/burp/application-security-testing/oast\nhttps://portswigger.net/research/cracking-the-lens-targeting-https-hidden-attack-surface",
        "color": "#FF0000",
        "severity": "High",
        "no": 8
    },
    {
        "port": "8888",
        "host": "https://localhost:8888/dvwa/vulnerabilities/captcha/\nhttps://localhost:8888/dvwa/vulnerabilities/upload/\nhttps://localhost:8888/dvwa/vulnerabilities/javascript/\nhttps://localhost:8888/dvwa/vulnerabilities/csp/\nhttps://localhost:8888/dvwa/vulnerabilities/weak_id/",
        "name": "Cross-site request forgery",
        "description": "Cross-site request forgery (CSRF) vulnerabilities may arise when applications rely solely on HTTP cookies to identify the user that has issued a particular request. Because browsers automatically add cookies to requests regardless of their origin, it may be possible for an attacker to create a malicious web site that forges a cross-domain request to the vulnerable application. For a request to be vulnerable to CSRF, the following conditions must hold:\n\nThe request can be issued cross-domain, for example using an HTML form. If the request contains non-standard headers or body content, then it may only be issuable from a page that originated on the same domain.\nThe application relies solely on HTTP cookies or Basic Authentication to identify the user that issued the request. If the application places session-related tokens elsewhere within the request, then it may not be vulnerable.\nThe request performs some privileged action within the application, which modifies the application's state based on the identity of the issuing user.The attacker can determine all the parameters required to construct a request that performs the action. If the request contains any values that the attacker cannot determine or predict, then it is not vulnerable.",
        "solution": "The most effective way to protect against CSRF vulnerabilities is to include within relevant requests an additional token that is not transmitted in a cookie: for example, a parameter in a hidden form field. This additional token should contain sufficient entropy, and be generated using a cryptographic random number generator, such that it is not feasible for an attacker to determine or predict the value of any token that was issued to another user. The token should be associated with the user's session, and the application should validate that the correct token is received before performing any action resulting from the request.\nAn alternative approach, which may be easier to implement, is to validate that Host and Referer headers in relevant requests are both present and contain the same domain name. However, this approach is somewhat less robust: historically, quirks in browsers and plugins have often enabled attackers to forge cross-domain requests that manipulate these headers to bypass such defenses. ",
        "remark": "https://portswigger.net/web-security/csrf\nhttps://support.portswigger.net/customer/portal/articles/1965674-using-burp-to-test-for-cross-site-request-forgery-csrf-\nhttps://media.blackhat.com/eu-13/briefings/Lundeen/bh-eu-13-deputies-still-confused-lundeen-wp.pdf",
        "color": "#FFC000",
        "severity": "Medium",
        "no": 9
    },
    {
        "port": "8888",
        "host": "https://localhost:8888/dvwa/vulnerabilities/csrf/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/sqli/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/view_source.php [security parameter]\nhttps://localhost:8888/dvwa/vulnerabilities/view_source.php [id parameter]\nhttps://localhost:8888/dvwa/vulnerabilities/upload/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/csrf/test_credentials.php [username parameter]\nhttps://localhost:8888/dvwa/vulnerabilities/javascript/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/fi/ [Referer HTTP header]\nhttps://localhost:8888/dvwa/vulnerabilities/sqli_blind/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/fi/ [User-Agent HTTP header]\nhttps://localhost:8888/dvwa/vulnerabilities/xss_s/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/csp/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/csp/ [include parameter]\nhttps://localhost:8888/dvwa/vulnerabilities/xss_r/ [name parameter]\nhttps://localhost:8888/dvwa/vulnerabilities/xss_r/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/captcha/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/brute/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/fi/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/weak_id/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/exec/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/xss_d/ [security cookie]",
        "name": "Cross-site scripting (reflected)",
        "description": "Reflected cross-site scripting vulnerabilities arise when data is copied from a request and echoed into the application's immediate response in an unsafe way. An attacker can use the vulnerability to construct a request that, if issued by another application user, will cause JavaScript code supplied by the attacker to execute within the user's browser in the context of that user's session with the application.\nThe attacker-supplied code can perform a wide variety of actions, such as stealing the victim's session token or login credentials, performing arbitrary actions on the victim's behalf, and logging their keystrokes.\nUsers can be induced to issue the attacker's crafted request in various ways. For example, the attacker can send a victim a link containing a malicious URL in an email or instant message. They can submit the link to popular web sites that allow content authoring, for example in blog comments. And they can create an innocuous looking web site that causes anyone viewing it to make arbitrary cross-domain requests to the vulnerable application (using either the GET or the POST method).\nThe security impact of cross-site scripting vulnerabilities is dependent upon the nature of the vulnerable application, the kinds of data and functionality that it contains, and the other applications that belong to the same domain and organization. If the application is used only to display non-sensitive public content, with no authentication or access control functionality, then a cross-site scripting flaw may be considered low risk. However, if the same application resides on a domain that can access cookies for other more security-critical applications, then the vulnerability could be used to attack those other applications, and so may be considered high risk. Similarly, if the organization that owns the application is a likely target for phishing attacks, then the vulnerability could be leveraged to lend credibility to such attacks, by injecting Trojan functionality into the vulnerable application and exploiting users' trust in the organization in order to capture credentials for other applications that it owns. In many kinds of application, such as those providing online banking functionality, cross-site scripting should always be considered high risk. ",
        "solution": "In most situations where user-controllable data is copied into application responses, cross-site scripting \n  attacks can be prevented using two layers of defenses:\n\n  Input should be validated as strictly as possible on arrival, given the kind of content that \nit is expected to contain. For example, personal names should consist of alphabetical \nand a small range of typographical characters, and be relatively short; a year of birth \nshould consist of exactly four numerals; email addresses should match a well-defined \nregular expression. Input which fails the validation should be rejected, not sanitized.\nUser input should be HTML-encoded at any point where it is copied into \napplication responses. All HTML metacharacters, including &lt; &gt; \" ' and =, should be \nreplaced with the corresponding HTML entities (&amp;lt; &amp;gt; etc).\nIn cases where the application's functionality allows users to author content using \n  a restricted subset of HTML tags and attributes (for example, blog comments which \n  allow limited formatting and linking), it is necessary to parse the supplied HTML to \n  validate that it does not use any dangerous syntax; this is a non-trivial task.",
        "remark": "https://portswigger.net/web-security/cross-site-scripting\nhttps://portswigger.net/web-security/cross-site-scripting/reflected\nhttps://support.portswigger.net/customer/portal/articles/1965737-Methodology_XSS.html",
        "color": "#FFC000",
        "severity": "Medium",
        "no": 10
    },
    {
        "port": "8888",
        "host": "https://localhost:8888/dvwa/security.php\nhttps://localhost:8888/dvwa/",
        "name": "TLS cookie without secure flag set",
        "description": "If the secure flag is set on a cookie, then browsers will not submit the cookie in any requests that use an unencrypted HTTP connection, thereby preventing the cookie from being trivially intercepted by an attacker monitoring network traffic. If the secure flag is not set, then the cookie will be transmitted in clear-text if the user visits any HTTP URLs within the cookie's scope. An attacker may be able to induce this event by feeding a user suitable links, either directly or via another web site. Even if the domain that issued the cookie does not host any content that is accessed over HTTP, an attacker may be able to use links of the form http://example.com:443/ to perform the same attack.\nTo exploit this vulnerability, an attacker must be suitably positioned to eavesdrop on the victim's network traffic. This scenario typically occurs when a client communicates with the server over an insecure connection such as public Wi-Fi, or a corporate or home network that is shared with a compromised computer. Common defenses such as switched networks are not sufficient to prevent this. An attacker situated in the user's ISP or the application's hosting infrastructure could also perform this attack. Note that an advanced adversary could potentially target any connection made over the Internet's core infrastructure.",
        "solution": "The secure flag should be set on all cookies that are used for transmitting sensitive data when accessing content over HTTPS. If cookies are used to transmit session tokens, then areas of the application that are accessed over HTTPS should employ their own session handling mechanism, and the session tokens used should never be transmitted over unencrypted communications.",
        "remark": "",
        "color": "#FFC000",
        "severity": "Medium",
        "no": 11
    },
    {
        "port": "8888",
        "host": "https://localhost:8888/",
        "name": "TLS certificate",
        "description": "TLS (or SSL) helps to protect the confidentiality and integrity of information in transit between the browser and server, and to provide authentication of the server's identity. To serve this purpose, the server must present an TLS certificate that is valid for the server's hostname, is issued by a trusted authority and is valid for the current date. If any one of these requirements is not met, TLS connections to the server will not provide the full protection for which TLS is designed.\nIt should be noted that various attacks exist against TLS in general, and in the context of HTTPS web connections in particular. It may be possible for a determined and suitably-positioned attacker to compromise TLS connections without user detection even when a valid TLS certificate is used. ",
        "solution": "",
        "remark": "https://wiki.mozilla.org/Security/Server_Side_TLS",
        "color": "#FFC000",
        "severity": "Medium",
        "no": 12
    },
    {
        "port": "8888",
        "host": "https://localhost:8888/dvwa/vulnerabilities/csrf/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/sqli/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/view_source.php [security parameter]\nhttps://localhost:8888/dvwa/vulnerabilities/view_source.php [id parameter]\nhttps://localhost:8888/dvwa/vulnerabilities/upload/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/csrf/test_credentials.php [username parameter]\nhttps://localhost:8888/dvwa/vulnerabilities/javascript/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/fi/ [Referer HTTP header]\nhttps://localhost:8888/dvwa/vulnerabilities/sqli_blind/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/fi/ [User-Agent HTTP header]\nhttps://localhost:8888/dvwa/vulnerabilities/xss_s/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/csp/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/csp/ [include parameter]\nhttps://localhost:8888/dvwa/vulnerabilities/xss_r/ [name parameter]\nhttps://localhost:8888/dvwa/vulnerabilities/xss_r/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/captcha/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/brute/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/fi/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/weak_id/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/exec/ [security cookie]\nhttps://localhost:8888/dvwa/vulnerabilities/xss_d/ [security cookie]",
        "name": "Cross-site scripting (reflected)",
        "description": "Reflected cross-site scripting vulnerabilities arise when data is copied from a request and echoed into the application's immediate response in an unsafe way. An attacker can use the vulnerability to construct a request that, if issued by another application user, will cause JavaScript code supplied by the attacker to execute within the user's browser in the context of that user's session with the application.\nThe attacker-supplied code can perform a wide variety of actions, such as stealing the victim's session token or login credentials, performing arbitrary actions on the victim's behalf, and logging their keystrokes.\nUsers can be induced to issue the attacker's crafted request in various ways. For example, the attacker can send a victim a link containing a malicious URL in an email or instant message. They can submit the link to popular web sites that allow content authoring, for example in blog comments. And they can create an innocuous looking web site that causes anyone viewing it to make arbitrary cross-domain requests to the vulnerable application (using either the GET or the POST method).\nThe security impact of cross-site scripting vulnerabilities is dependent upon the nature of the vulnerable application, the kinds of data and functionality that it contains, and the other applications that belong to the same domain and organization. If the application is used only to display non-sensitive public content, with no authentication or access control functionality, then a cross-site scripting flaw may be considered low risk. However, if the same application resides on a domain that can access cookies for other more security-critical applications, then the vulnerability could be used to attack those other applications, and so may be considered high risk. Similarly, if the organization that owns the application is a likely target for phishing attacks, then the vulnerability could be leveraged to lend credibility to such attacks, by injecting Trojan functionality into the vulnerable application and exploiting users' trust in the organization in order to capture credentials for other applications that it owns. In many kinds of application, such as those providing online banking functionality, cross-site scripting should always be considered high risk. ",
        "solution": "In most situations where user-controllable data is copied into application responses, cross-site scripting \n  attacks can be prevented using two layers of defenses:\n\n  Input should be validated as strictly as possible on arrival, given the kind of content that \nit is expected to contain. For example, personal names should consist of alphabetical \nand a small range of typographical characters, and be relatively short; a year of birth \nshould consist of exactly four numerals; email addresses should match a well-defined \nregular expression. Input which fails the validation should be rejected, not sanitized.\nUser input should be HTML-encoded at any point where it is copied into \napplication responses. All HTML metacharacters, including &lt; &gt; \" ' and =, should be \nreplaced with the corresponding HTML entities (&amp;lt; &amp;gt; etc).\nIn cases where the application's functionality allows users to author content using \n  a restricted subset of HTML tags and attributes (for example, blog comments which \n  allow limited formatting and linking), it is necessary to parse the supplied HTML to \n  validate that it does not use any dangerous syntax; this is a non-trivial task.",
        "remark": "https://portswigger.net/web-security/cross-site-scripting\nhttps://portswigger.net/web-security/cross-site-scripting/reflected\nhttps://support.portswigger.net/customer/portal/articles/1965737-Methodology_XSS.html",
        "color": "#FFFF00",
        "severity": "Low",
        "no": 13
    },
    {
        "port": "8888",
        "host": "https://localhost:8888/dvwa/security.php\nhttps://localhost:8888/dvwa/",
        "name": "Cookie without HttpOnly flag set",
        "description": "If the HttpOnly attribute is set on a cookie, then the cookie's value cannot be read or set by client-side JavaScript. This measure makes certain client-side attacks, such as cross-site scripting, slightly harder to exploit by preventing them from trivially capturing the cookie's value via an injected script.",
        "solution": "There is usually no good reason not to set the HttpOnly flag on all cookies. Unless you specifically require legitimate client-side scripts within your application to read or set a cookie's value, you should set the HttpOnly flag by including this attribute within the relevant Set-cookie directive.\nYou should be aware that the restrictions imposed by the HttpOnly flag can potentially be circumvented in some circumstances, and that numerous other serious attacks can be delivered by client-side script injection, aside from simple cookie stealing. ",
        "remark": "",
        "color": "#FFFF00",
        "severity": "Low",
        "no": 14
    },
    {
        "port": "8888",
        "host": "https://localhost:8888/dvwa/vulnerabilities/brute/\nhttps://localhost:8888/dvwa/vulnerabilities/csrf/",
        "name": "Password submitted using GET method",
        "description": "Some applications use the GET method to submit passwords, which are transmitted within the query string of the requested URL. Sensitive information within URLs may be logged in various locations, including the user's browser, the web server, and any forward or reverse proxy servers between the two endpoints. URLs may also be displayed on-screen, bookmarked or emailed around by users. They may be disclosed to third parties via the Referer header when any off-site links are followed. Placing passwords into the URL increases the risk that they will be captured by an attacker.\nVulnerabilities that result in the disclosure of users' passwords can result in compromises that are extremely difficult to investigate due to obscured audit trails. Even if the application itself only handles non-sensitive information, exposing passwords puts users who have re-used their password elsewhere at risk.",
        "solution": "All forms submitting passwords should use the POST method. To achieve this, applications should specify the method attribute of the FORM tag as method=\"POST\". It may also be necessary to modify the corresponding server-side form handler to ensure that submitted passwords are properly retrieved from the message body, rather than the URL.\n",
        "remark": "",
        "color": "#FFFF00",
        "severity": "Low",
        "no": 15
    },
    {
        "port": "8888",
        "host": "https://localhost:8888/dvwa",
        "name": "Strict transport security not enforced",
        "description": " The application fails to prevent users from connecting  to it over unencrypted connections.  An attacker able to modify a legitimate user's network traffic could bypass the application's use of SSL/TLS encryption, and use the application as a platform for attacks against its users. This attack is performed by rewriting HTTPS links as HTTP, so that if a targeted user follows a link to the site from an HTTP page, their browser never attempts to use an encrypted connection. The sslstrip tool  automates this process. \n\nTo exploit this vulnerability, an attacker must be suitably positioned to intercept and modify the victim's network traffic.This scenario typically occurs when a client communicates with the server over an insecure connection such as public Wi-Fi, or a corporate or home network that is shared with a compromised computer. Common defenses such as switched networks are not sufficient to prevent this. An attacker situated in the user's ISP or the application's hosting infrastructure could also perform this attack. Note that an advanced adversary could potentially target any connection made over the Internet's core infrastructure. ",
        "solution": "The application should instruct web browsers to only access the application using HTTPS. To do this, enable HTTP Strict Transport Security (HSTS) by adding a response header with the name 'Strict-Transport-Security' and the value 'max-age=expireTime', where expireTime is the time in seconds that browsers should remember that the site should only be accessed using HTTPS. Consider adding the 'includeSubDomains' flag if appropriate.\nNote that because HSTS is a &quot;trust on first use&quot; (TOFU) protocol, a user who has never accessed the application will never have seen the HSTS header, and will therefore still be vulnerable to SSL stripping attacks. To mitigate this risk, you can optionally add the 'preload' flag to the HSTS header, and submit the domain for review by browser vendors.",
        "remark": "https://developer.mozilla.org/en-US/docs/Web/Security/HTTP_strict_transport_security\nhttps://github.com/moxie0/sslstrip\nhttps://hstspreload.appspot.com/",
        "color": "#FFFF00",
        "severity": "Low",
        "no": 16
    }
]